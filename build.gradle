import com.google.common.base.Strings;

buildscript {
    repositories {
        jcenter()
        mavenCentral()
        maven {
            name = "forge"
            url = "http://files.minecraftforge.net/maven"
        }
    }
    dependencies {
        classpath group: 'net.minecraftforge.gradle', name: 'ForgeGradle', version: '3.+', changing: true
    }
}

apply plugin: 'net.minecraftforge.gradle'
apply plugin: 'eclipse'

repositories {

	maven {
		url "http://tehnut.info/maven"
	}
	
}

ext.configFile = file "build.properties"

configFile.withReader {
    def prop = new Properties()
    prop.load(it)
    project.ext.config = new ConfigSlurper().parse prop
    String build = System.getenv("BUILD_NUMBER")
    boolean localBuild = Strings.isNullOrEmpty(build)

    String temp = config.mod_version
    String classifier = config.mod_classifier
    classifier = Strings.isNullOrEmpty(classifier) ? "" : "-" + classifier
	project.ext.modVersion = temp + "." + (localBuild ? "9999.custom" : build)
    config.mod_version = "${config.minecraft_version}-" + temp + "." + (localBuild ? "localBuild" : build) + classifier
}

version = config.mod_version
group = "nl.elec332.core" // http://maven.apache.org/guides/mini/guide-naming-conventions.html
archivesBaseName = "ElecCore"

sourceCompatibility = targetCompatibility = compileJava.sourceCompatibility = compileJava.targetCompatibility = '1.8'

minecraft {

	accessTransformer = file 'src/main/resources/META-INF/accesstransformer.cfg'

    mappings channel: 'snapshot', version: config.mappings

    runs {
        client {
            workingDirectory project.file('run')

            mods {
                eleccore {
                    source sourceSets.main
                }
            }
        }

        server {
            workingDirectory project.file('run')

            mods {
                eleccore {
                    source sourceSets.main
                }
            }
        }

        data {
            workingDirectory project.file('run')

            args '--mod', 'eleccore', '--all', '--output', file('src/generated/resources/')

            mods {
                eleccore {
                    source sourceSets.main
                }
            }
        }

    }

}

dependencies {

	minecraft 'net.minecraftforge:forge:' + config.minecraft_version + "-" + config.forge_version

	//WAILA
    compile "mcp.mobius.waila:Hwyla:${config.WAILA_version}"
    //compile fg.deobf("mcp.mobius.waila:Hwyla:${config.WAILA_version}")
	//deobfCompile "mcp.mobius.waila:Hwyla:${config.WAILA_version}"
	
	//JEI
	///deobfCompile "mezz.jei:jei_${config.jei_version}"
	
	//MCMP
	//deobfCompile "MCMultiPart2:MCMultiPart:${config.mcmp_version}:deobf"
	
	//Forestry
	//deobfCompile "net.sengir.forestry:forestry_${config.minecraft_version}:${config.forestry_version}"
	//deobfCompile "net.sengir.forestry:forestry_${config.forestry_version}"
	//deobfCompile "cofhcore:CoFHCore-1.10.2:release:universal"
	//deobfCompile "eleccore-rendering-library:ElecCore:1.10.2:1.7.425"
}

processResources {

    // this will ensure that this task is redone when the versions change.
    inputs.property "version", modVersion
    inputs.property "mcversion", config.minecraft_version

    // replace stuff in mcmod.info, nothing else
    from(sourceSets.main.resources.srcDirs) {
        include 'META_INF/mods.toml'
                
        // replace version and mcversion
        expand 'version': modVersion, 'mcversion': config.minecraft_version, 'loaderversion': config.minecraft_version.replace('1.', '')
        expand 'forgeversion': config.forge_version
    }
        
    // copy everything else, thats not the mcmod.info
    from(sourceSets.main.resources.srcDirs) {
        exclude 'META_INF/mods.toml'
    }

}

jar {
    manifest {
		//attributes	'FMLAT': 'eleccore_at.cfg' All AT's are now named "accesstransformer.cfg", and will be found automatically by FML

        attributes([
                'Specification-Title': 'ElecCoreAPI',
                'Specification-Version': '2.0'
        ] as LinkedHashMap, 'elec332.core.api')

        attributes([
                'Specification-Title': archivesBaseName,
                'Specification-Version': modVersion,
                'Implementation-Title': archivesBaseName,
                'Implementation-Version': modVersion
        ] as LinkedHashMap, 'elec332.core')

    }
}

tasks.build.dependsOn('deobfJar')

task deobfJar(type: Jar) { // Generate deobfuscated
    from sourceSets.main.output
    classifier = 'deobf'
}


//Maven magic
task("uploadJars", dependsOn: "reobf") {
    description = "uploads JARs"
    if (System.getenv("local_maven") != null) {
        apply plugin: 'maven'
        uploadArchives {
            repositories {
                mavenDeployer {
                    repository(url: "file://" + System.getenv("local_maven"))
                    pom {
                        groupId = project.group
                        version = project.version
                        artifactId = project.archivesBaseName
                        project {
                            name project.archivesBaseName
                            packaging 'jar'
                            description project.archivesBaseName
                            issueManagement {
                                system 'github'
                                url 'https://github.com/Elecs-Mods/ElecCore/issues'
                            }
                            developers {
                                developer {
                                    id 'Elec332'
                                    name 'Elec332'
                                    roles {
                                        role 'developer'
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}
